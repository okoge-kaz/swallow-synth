PYTHON_STAGE8_REWRITE_PROMPT = """
You are an expert Python coder tasked with refining a code corpus already rewritten to high quality in a first stage (e.g., Pythonic, documented, modular, robust). Perform a second-stage rewrite to enhance efficiency, clarity, and educational value. Prioritize Python's standard library and built-in functions (e.g., dict for mappings like string-to-int, set for uniques, sorted for min/max distances, itertools.combinations for combinations). Use uppercase constants. If the original code includes a triple-quoted implementation strategy at the start, redistribute its relevant parts into the docstrings of individual functions. Ensure each function docstring starts with an abstract purpose clarifying the problem's goal, followed by a step-by-step implementation strategy, and—for complex or ambiguous cases—includes doctest-style examples (e.g., >>> function_call\nexpected_output) to illustrate behavior, edge cases, and intent. Verify perfect alignment between the docstring's purpose, strategy, examples, and the function’s code. The rules below guide this refinement, each targeting a distinct aspect.

1. Standard Library Optimization: Simplify logic using built-in functions and standard library modules (e.g., dict for mappings/frequencies, set for uniques, sorted for distances, itertools.combinations). Include length checks for string/list operations to prevent errors like IndexError.
2. Function-Specific Documentation: Relocate any top-level implementation strategy into function docstrings. Each docstring must include: (a) an abstract purpose clarifying the problem’s goal; (b) a step-by-step strategy specific to the function’s logic; (c) doctest-style examples for complex cases, showing typical, edge, and failure scenarios.
3. Refined Error Handling: Enhance error handling for edge cases (e.g., empty inputs, invalid mappings) as outlined in function strategies and examples, using try-except for potential built-in errors.
4. Modular Refinement: Retain type annotations and modularize complex logic into single-responsibility functions or clear steps (e.g., is_prime(n: int) -> bool, is_palindrome(s: str) -> bool if needed), favoring procedural style unless classes are justified.
5. Generalization: Ensure self-containment with top-level imports and uppercase constants. Generalize fixed logic (e.g., via argparse for variable inputs) for reusability.
6. Performance and Structure: Optimize with efficient built-ins (e.g., dict/set for O(1), sorted for O(n log n)) and organize into imports, constants, functions, and main block.
7. Educational Value: Enhance for learners by expanding typical implementations into practical examples (e.g., variable bases, dynamic inputs), with clear purpose, strategy, and examples in docstrings.
8. Strategic Thinking: Analyze the first-stage code’s purpose, redistribute top-level strategy into function docstrings with clear intent and examples, plan step-by-step refinements, and verify docstring-code alignment, including example consistency.

Please generate the rewritten code after '<|REWRITTEN_CODE|>: ```python'.
"""
